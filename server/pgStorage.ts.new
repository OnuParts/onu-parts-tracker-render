import pg from 'pg';
const { Pool } = pg;
import { 
  User, InsertUser, 
  Building, InsertBuilding, 
  Part, InsertPart, 
  PartsIssuance, InsertPartsIssuance, 
  PartWithAvailability,
  PartsIssuanceWithDetails,
  PartsToCount, InsertPartsToCount,
  PartsToCountWithDetails,
  StorageLocation, InsertStorageLocation,
  Shelf, InsertShelf
} from '@shared/schema';
import { IStorage, NotificationSettings } from './storage';
import { log } from './vite';

// Initialize PostgreSQL connection pool from environment variables
const pool = new Pool({
  connectionString: process.env.DATABASE_URL
});

// Test database connection
pool.query('SELECT NOW()', (err, res) => {
  if (err) {
    log(`Database connection error: ${err.message}`, 'postgres');
  } else {
    log(`Database connected at ${res.rows[0].now}`, 'postgres');
  }
});

/**
 * PostgreSQL Storage Implementation
 */
export class PgStorage implements IStorage {
  private initialized: boolean = false;
  private pool: pg.Pool;
  private notificationSettings: NotificationSettings = {
    system: {
      companyName: "Ohio Northern University",
      systemEmail: "m-gierhart@onu.edu"
    },
    workOrders: {
      newWorkOrders: true,
      statusChanges: true,
      comments: true,
    },
    inventory: {
      lowStockAlerts: true,
      partIssuance: true,
    }
  };

  constructor() {
    this.pool = pool; // Use the globally initialized pool
    this.initDb();
  }

  /**
   * Initialize the database tables if they don't exist
   */
  public async initDb() {
    if (this.initialized) return;

    try {
      // Start a transaction
      const client = await pool.connect();
      
      try {
        await client.query('BEGIN');

        // Create users table
        await client.query(`
          CREATE TABLE IF NOT EXISTS users (
            id SERIAL PRIMARY KEY,
            username VARCHAR(50) UNIQUE NOT NULL,
            password VARCHAR(100) NOT NULL,
            name VARCHAR(100) NOT NULL,
            email VARCHAR(100),
            role VARCHAR(20) NOT NULL,
            department VARCHAR(100),
            phone VARCHAR(20),
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          )
        `);

        // Create buildings table
        await client.query(`
          CREATE TABLE IF NOT EXISTS buildings (
            id SERIAL PRIMARY KEY,
            name VARCHAR(100) NOT NULL,
            location VARCHAR(100),
            description TEXT,
            contact_person VARCHAR(100),
            contact_email VARCHAR(100),
            contact_phone VARCHAR(20),
            active BOOLEAN DEFAULT TRUE,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          )
        `);

        // Create parts table
        await client.query(`
          CREATE TABLE IF NOT EXISTS parts (
            id SERIAL PRIMARY KEY,
            part_id VARCHAR(50) UNIQUE NOT NULL,
            name VARCHAR(100) NOT NULL,
            description TEXT,
            quantity INTEGER NOT NULL DEFAULT 0,
            reorder_level INTEGER,
            unit_cost DECIMAL(10, 2),
            category VARCHAR(50),
            location VARCHAR(100),
            supplier VARCHAR(100),
            last_restock_date TIMESTAMP,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          )
        `);

        // Create parts_issuance table
        await client.query(`
          CREATE TABLE IF NOT EXISTS parts_issuance (
            id SERIAL PRIMARY KEY,
            part_id INTEGER NOT NULL REFERENCES parts(id) ON DELETE CASCADE,
            quantity INTEGER NOT NULL,
            issued_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            issued_to VARCHAR(100),
            issued_by INTEGER REFERENCES users(id),
            reason VARCHAR(50) NOT NULL,
            project_code VARCHAR(50),
            notes TEXT
          )
        `);

        // Create notification_settings table
        await client.query(`
          CREATE TABLE IF NOT EXISTS notification_settings (
            id SERIAL PRIMARY KEY,
            work_orders_new BOOLEAN DEFAULT TRUE,
            work_orders_status BOOLEAN DEFAULT TRUE,
            work_orders_comments BOOLEAN DEFAULT TRUE,
            inventory_low_stock BOOLEAN DEFAULT TRUE,
            inventory_issuance BOOLEAN DEFAULT TRUE,
            company_name VARCHAR(100) DEFAULT 'Ohio Northern University',
            system_email VARCHAR(100) DEFAULT 'm-gierhart@onu.edu',
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          )
        `);
        
        // Check if parts_to_count table exists first to avoid duplicate error
        const tableCheckResult = await client.query(`
          SELECT EXISTS (
            SELECT FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'parts_to_count'
          );
        `);
        
        if (!tableCheckResult.rows[0].exists) {
          // Create parts_to_count table only if it doesn't exist
          await client.query(`
            CREATE TABLE parts_to_count (
              id SERIAL PRIMARY KEY,
              part_id INTEGER NOT NULL REFERENCES parts(id) ON DELETE CASCADE,
              assigned_by_id INTEGER REFERENCES users(id),
              status VARCHAR(20) NOT NULL DEFAULT 'pending',
              assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
              completed_at TIMESTAMP,
              notes TEXT
            )
          `);
        }

        // Insert default notification settings if none exist
        await client.query(`
          INSERT INTO notification_settings 
            (work_orders_new, work_orders_status, work_orders_comments, 
             inventory_low_stock, inventory_issuance)
          SELECT TRUE, TRUE, TRUE, TRUE, TRUE
          WHERE NOT EXISTS (SELECT 1 FROM notification_settings)
        `);

        // Insert admin user if no users exist
        await client.query(`
          INSERT INTO users (username, password, name, email, role)
          SELECT 'admin', 'admin', 'Administrator', 'm-gierhart@onu.edu', 'admin'
          WHERE NOT EXISTS (SELECT 1 FROM users)
        `);

        await client.query('COMMIT');
        this.initialized = true;
        log('Database tables initialized successfully', 'postgres');
      } catch (err) {
        await client.query('ROLLBACK');
        log(`Database initialization error: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
        throw err;
      } finally {
        client.release();
      }
    } catch (err) {
      log(`Database connection error: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
    }
  }

  // User operations
  async getUser(id: number): Promise<User | undefined> {
    try {
      const result = await pool.query(
        'SELECT * FROM users WHERE id = $1',
        [id]
      );
      
      if (result.rows.length === 0) {
        return undefined;
      }
      
      const row = result.rows[0];
      return {
        id: row.id,
        username: row.username,
        password: row.password,
        name: row.name,
        role: row.role,
        department: row.department
      };
    } catch (err) {
      log(`Error retrieving user: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return undefined;
    }
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    try {
      const result = await pool.query(
        'SELECT * FROM users WHERE username = $1',
        [username]
      );
      
      if (result.rows.length === 0) {
        return undefined;
      }
      
      const row = result.rows[0];
      return {
        id: row.id,
        username: row.username,
        password: row.password,
        name: row.name,
        role: row.role,
        department: row.department
      };
    } catch (err) {
      log(`Error retrieving user by username: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return undefined;
    }
  }

  async createUser(user: InsertUser): Promise<User> {
    try {
      const result = await pool.query(
        `INSERT INTO users (username, password, name, role, department)
         VALUES ($1, $2, $3, $4, $5)
         RETURNING *`,
        [
          user.username,
          user.password,
          user.name,
          user.role,
          user.department
        ]
      );
      
      const row = result.rows[0];
      return {
        id: row.id,
        username: row.username,
        password: row.password,
        name: row.name,
        role: row.role,
        department: row.department
      };
    } catch (err) {
      log(`Error creating user: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      throw new Error(`Failed to create user: ${err instanceof Error ? err.message : String(err)}`);
    }
  }

  async updateUser(id: number, user: Partial<InsertUser>): Promise<User | undefined> {
    try {
      // Build dynamic query based on provided fields
      const updates: string[] = [];
      const values: any[] = [];
      let paramIndex = 1;

      if (user.username !== undefined) {
        updates.push(`username = $${paramIndex++}`);
        values.push(user.username);
      }
      if (user.password !== undefined) {
        updates.push(`password = $${paramIndex++}`);
        values.push(user.password);
      }
      if (user.name !== undefined) {
        updates.push(`name = $${paramIndex++}`);
        values.push(user.name);
      }
      if (user.role !== undefined) {
        updates.push(`role = $${paramIndex++}`);
        values.push(user.role);
      }
      if (user.department !== undefined) {
        updates.push(`department = $${paramIndex++}`);
        values.push(user.department);
      }

      if (updates.length === 0) {
        return await this.getUser(id);
      }

      values.push(id);
      const query = `
        UPDATE users 
        SET ${updates.join(', ')} 
        WHERE id = $${paramIndex} 
        RETURNING *
      `;

      const result = await pool.query(query, values);
      
      if (result.rows.length === 0) {
        return undefined;
      }
      
      const row = result.rows[0];
      return {
        id: row.id,
        username: row.username,
        password: row.password,
        name: row.name,
        role: row.role,
        department: row.department
      };
    } catch (err) {
      log(`Error updating user: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return undefined;
    }
  }

  async getUsers(): Promise<User[]> {
    try {
      const result = await pool.query('SELECT * FROM users ORDER BY name');
      
      return result.rows.map(row => ({
        id: row.id,
        username: row.username,
        password: row.password,
        name: row.name,
        role: row.role,
        department: row.department
      }));
    } catch (err) {
      log(`Error retrieving users: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return [];
    }
  }

  async getTechnicians(): Promise<User[]> {
    try {
      const result = await pool.query(
        "SELECT * FROM users WHERE role = 'technician' ORDER BY name"
      );
      
      return result.rows.map(row => ({
        id: row.id,
        username: row.username,
        password: row.password,
        name: row.name,
        role: row.role,
        department: row.department
      }));
    } catch (err) {
      log(`Error retrieving technicians: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return [];
    }
  }

  async deleteUser(id: number): Promise<boolean> {
    try {
      const result = await pool.query(
        'DELETE FROM users WHERE id = $1',
        [id]
      );
      
      return result.rowCount > 0;
    } catch (err) {
      log(`Error deleting user: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return false;
    }
  }

  // Building operations
  async getBuilding(id: number): Promise<Building | undefined> {
    try {
      const result = await pool.query(
        'SELECT * FROM buildings WHERE id = $1',
        [id]
      );
      
      if (result.rows.length === 0) {
        return undefined;
      }
      
      const row = result.rows[0];
      return {
        id: row.id,
        name: row.name,
        location: row.location,
        description: row.description,
        contactPerson: row.contact_person,
        contactEmail: row.contact_email,
        contactPhone: row.contact_phone,
        active: row.active !== false,
        createdAt: row.created_at
      };
    } catch (err) {
      log(`Error retrieving building: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return undefined;
    }
  }

  async getBuildings(): Promise<Building[]> {
    try {
      const result = await pool.query('SELECT * FROM buildings ORDER BY name');
      
      return result.rows.map(row => ({
        id: row.id,
        name: row.name,
        location: row.location,
        description: row.description,
        contactPerson: row.contact_person,
        contactEmail: row.contact_email,
        contactPhone: row.contact_phone,
        active: row.active !== false, // Default to true if not explicitly set to false
        createdAt: row.created_at
      }));
    } catch (err) {
      log(`Error retrieving buildings: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return [];
    }
  }

  async createBuilding(building: InsertBuilding): Promise<Building> {
    try {
      const result = await pool.query(
        `INSERT INTO buildings (
           name, location, description, contact_person, 
           contact_email, contact_phone, active
         )
         VALUES ($1, $2, $3, $4, $5, $6, $7)
         RETURNING *`,
        [
          building.name,
          building.location,
          building.description,
          building.contactPerson,
          building.contactEmail,
          building.contactPhone,
          building.active !== undefined ? building.active : true
        ]
      );
      
      const row = result.rows[0];
      return {
        id: row.id,
        name: row.name,
        location: row.location,
        description: row.description,
        contactPerson: row.contact_person,
        contactEmail: row.contact_email,
        contactPhone: row.contact_phone
      };
    } catch (err) {
      log(`Error creating building: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      throw new Error(`Failed to create building: ${err instanceof Error ? err.message : String(err)}`);
    }
  }

  async updateBuilding(id: number, building: Partial<InsertBuilding>): Promise<Building | undefined> {
    try {
      // Build dynamic query based on provided fields
      const updates: string[] = [];
      const values: any[] = [];
      let paramIndex = 1;

      if (building.name !== undefined) {
        updates.push(`name = $${paramIndex++}`);
        values.push(building.name);
      }
      if (building.location !== undefined) {
        updates.push(`location = $${paramIndex++}`);
        values.push(building.location);
      }
      if (building.description !== undefined) {
        updates.push(`description = $${paramIndex++}`);
        values.push(building.description);
      }
      if (building.contactPerson !== undefined) {
        updates.push(`contact_person = $${paramIndex++}`);
        values.push(building.contactPerson);
      }
      if (building.contactEmail !== undefined) {
        updates.push(`contact_email = $${paramIndex++}`);
        values.push(building.contactEmail);
      }
      if (building.contactPhone !== undefined) {
        updates.push(`contact_phone = $${paramIndex++}`);
        values.push(building.contactPhone);
      }

      if (updates.length === 0) {
        return await this.getBuilding(id);
      }

      values.push(id);
      const query = `
        UPDATE buildings 
        SET ${updates.join(', ')} 
        WHERE id = $${paramIndex} 
        RETURNING *
      `;

      const result = await pool.query(query, values);
      
      if (result.rows.length === 0) {
        return undefined;
      }
      
      const row = result.rows[0];
      return {
        id: row.id,
        name: row.name,
        location: row.location,
        description: row.description,
        contactPerson: row.contact_person,
        contactEmail: row.contact_email,
        contactPhone: row.contact_phone
      };
    } catch (err) {
      log(`Error updating building: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return undefined;
    }
  }

  async deleteBuilding(id: number): Promise<boolean> {
    try {
      const result = await pool.query(
        'DELETE FROM buildings WHERE id = $1',
        [id]
      );
      
      return result.rowCount > 0;
    } catch (err) {
      log(`Error deleting building: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return false;
    }
  }

  // Part operations
  async getPart(id: number): Promise<Part | undefined> {
    try {
      const result = await pool.query(
        'SELECT * FROM parts WHERE id = $1',
        [id]
      );
      
      if (result.rows.length === 0) {
        return undefined;
      }
      
      const row = result.rows[0];
      return {
        id: row.id,
        partId: row.part_id,
        name: row.name,
        description: row.description,
        quantity: row.quantity,
        reorderLevel: row.reorder_level,
        unitCost: row.unit_cost,
        category: row.category,
        location: row.location,
        // Include the location and shelf IDs
        locationId: row.location_id,
        shelfId: row.shelf_id,
        supplier: row.supplier,
        lastRestockDate: row.last_restock_date
      };
    } catch (err) {
      log(`Error retrieving part: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return undefined;
    }
  }

  async getPartByPartId(partId: string): Promise<Part | undefined> {
    try {
      console.log(`pgStorage.getPartByPartId - Looking for part with partId: "${partId}"`);
      
      // Add ILIKE to make the search case-insensitive and trim spaces
      const result = await pool.query(
        "SELECT * FROM parts WHERE part_id ILIKE $1",
        [partId.trim()]
      );
      
      console.log(`pgStorage.getPartByPartId - Query '${partId}' returned ${result.rows.length} rows`);
      
      if (result.rows.length === 0) {
        console.log(`pgStorage.getPartByPartId - No parts found with partId="${partId}"`);
        return undefined;
      }
      
      const row = result.rows[0];
      console.log(`pgStorage.getPartByPartId - Found part: ${row.part_id} - ${row.name}`);
      
      return {
        id: row.id,
        partId: row.part_id,
        name: row.name,
        description: row.description,
        quantity: row.quantity,
        reorderLevel: row.reorder_level,
        unitCost: row.unit_cost,
        category: row.category,
        location: row.location,
        supplier: row.supplier,
        lastRestockDate: row.last_restock_date,
        // Add the missing location/shelf ID fields
        locationId: row.location_id,
        shelfId: row.shelf_id
      };
    } catch (err) {
      log(`Error retrieving part by partId: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return undefined;
    }
  }

  async createPart(part: InsertPart): Promise<Part> {
    try {
      // Function to safely truncate strings to prevent DB errors
      const safeStr = (str: string | null | undefined, maxLen: number): string | null => {
        if (str === null || str === undefined) return null;
        const strVal = String(str);
        return strVal.length > maxLen ? strVal.substring(0, maxLen) : strVal;
      };
      
      // Apply size limits based on database table constraints
      const safePart = {
        partId: safeStr(part.partId, 50),
        name: safeStr(part.name, 100),
        description: part.description, // TEXT field doesn't need truncation
        quantity: part.quantity,
        reorderLevel: part.reorderLevel,
        unitCost: part.unitCost,
        category: safeStr(part.category, 50),
        location: safeStr(part.location, 100),
        supplier: safeStr(part.supplier, 100),
        lastRestockDate: part.lastRestockDate,
        // Add location IDs if they exist
        locationId: part.locationId,
        shelfId: part.shelfId
      };
      
      // Log part data for debugging
      console.log(`Creating part: ${safePart.partId}, ${safePart.name}`);
      
      const result = await pool.query(
        `INSERT INTO parts (
           part_id, name, description, quantity, reorder_level,
           unit_cost, category, location, supplier, last_restock_date,
           location_id, shelf_id
         )
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
         RETURNING *`,
        [
          safePart.partId,
          safePart.name,
          safePart.description,
          safePart.quantity,
          safePart.reorderLevel,
          safePart.unitCost,
          safePart.category,
          safePart.location,
          safePart.supplier,
          safePart.lastRestockDate,
          safePart.locationId,
          safePart.shelfId
        ]
      );
      
      const row = result.rows[0];
      return {
        id: row.id,
        partId: row.part_id,
        name: row.name,
        description: row.description,
        quantity: row.quantity,
        reorderLevel: row.reorder_level,
        unitCost: row.unit_cost,
        category: row.category,
        location: row.location,
        // Include the location IDs
        locationId: row.location_id,
        shelfId: row.shelf_id,
        supplier: row.supplier,
        lastRestockDate: row.last_restock_date
      };
    } catch (err) {
      log(`Error creating part: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      throw new Error(`Failed to create part: ${err instanceof Error ? err.message : String(err)}`);
    }
  }

  async updatePart(id: number, part: Partial<InsertPart>): Promise<Part | undefined> {
    try {
      console.log(`updatePart: Attempting to update part ID ${id} with data:`, part);
      
      // Function to safely truncate strings to prevent DB errors
      const safeStr = (str: string | null | undefined, maxLen: number): string | null => {
        if (str === null || str === undefined) return null;
        const strVal = String(str);
        return strVal.length > maxLen ? strVal.substring(0, maxLen) : strVal;
      };
      
      // Build dynamic query based on provided fields
      const updates: string[] = [];
      const values: any[] = [];
      let paramIndex = 1;

      if (part.partId !== undefined) {
        updates.push(`part_id = $${paramIndex++}`);
        values.push(safeStr(part.partId, 50));
      }
      if (part.name !== undefined) {
        updates.push(`name = $${paramIndex++}`);
        values.push(safeStr(part.name, 100));
      }
      if (part.description !== undefined) {
        updates.push(`description = $${paramIndex++}`);
        values.push(part.description); // TEXT field doesn't need truncation
      }
      if (part.quantity !== undefined) {
        updates.push(`quantity = $${paramIndex++}`);
        values.push(part.quantity);
      }
      if (part.reorderLevel !== undefined) {
        updates.push(`reorder_level = $${paramIndex++}`);
        values.push(part.reorderLevel);
      }
      if (part.unitCost !== undefined) {
        updates.push(`unit_cost = $${paramIndex++}`);
        values.push(part.unitCost);
      }
      if (part.category !== undefined) {
        updates.push(`category = $${paramIndex++}`);
        values.push(safeStr(part.category, 50));
      }
      // Handle both the text location and the foreign key locationId and shelfId
      if (part.location !== undefined) {
        updates.push(`location = $${paramIndex++}`);
        values.push(safeStr(part.location, 100));
        console.log(`Updating location text to: ${part.location}`);
      }
      
      // Handle locationId separately - properly save it as a database column
      if (part.locationId !== undefined) {
        updates.push(`location_id = $${paramIndex++}`);
        values.push(part.locationId);
        console.log(`Updating location_id to: ${part.locationId}`);
      }
      
      // Handle shelfId separately - properly save it as a database column
      if (part.shelfId !== undefined) {
        updates.push(`shelf_id = $${paramIndex++}`);
        values.push(part.shelfId);
        console.log(`Updating shelf_id to: ${part.shelfId}`);
      }
      if (part.supplier !== undefined) {
        updates.push(`supplier = $${paramIndex++}`);
        values.push(safeStr(part.supplier, 100));
      }
      if (part.lastRestockDate !== undefined) {
        updates.push(`last_restock_date = $${paramIndex++}`);
        values.push(part.lastRestockDate);
      }

      if (updates.length === 0) {
        // If no updates are provided, just return the existing part
        console.log(`updatePart: No updates provided, returning existing part`);
        return await this.getPart(id);
      }

      values.push(id);
      const query = `
        UPDATE parts 
        SET ${updates.join(', ')} 
        WHERE id = $${paramIndex} 
        RETURNING *
      `;
      
      console.log("Executing update query:", query);
      console.log("With values:", values);

      const result = await pool.query(query, values);
      
      if (result.rows.length === 0) {
        console.log(`updatePart: No rows returned after update. Part ID ${id} not found.`);
        return undefined;
      }
      
      const row = result.rows[0];
      console.log(`updatePart: Successfully updated part ID ${id}. Returned row:`, row);
      
      // CRITICAL FIX: Return the updated part with all fields mapped correctly
      return {
        id: row.id,
        partId: row.part_id,
        name: row.name,
        description: row.description,
        quantity: row.quantity,
        reorderLevel: row.reorder_level,
        unitCost: row.unit_cost,
        category: row.category,
        location: row.location,
        // Include the location IDs in the response
        locationId: row.location_id,
        shelfId: row.shelf_id,
        supplier: row.supplier,
        lastRestockDate: row.last_restock_date
      };
    } catch (err) {
      log(`Error updating part: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return undefined;
    }
  }

  async deletePart(id: number): Promise<boolean> {
    try {
      const result = await pool.query(
        'DELETE FROM parts WHERE id = $1',
        [id]
      );
      
      return result.rowCount > 0;
    } catch (err) {
      log(`Error deleting part: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return false;
    }
  }

  async getParts(): Promise<Part[]> {
    try {
      console.log('Fetching all parts from database...');
      const result = await pool.query('SELECT * FROM parts ORDER BY name');
      console.log(`Found ${result.rows.length} parts total in database`);
      
      if (result.rows.length > 0) {
        console.log('First part sample:', result.rows[0]);
      }
      
      // Return all parts with location and shelf IDs included
      return result.rows.map(row => {
        return {
          id: row.id,
          partId: row.part_id,
          name: row.name,
          description: row.description,
          quantity: row.quantity,
          reorderLevel: row.reorder_level,
          unitCost: row.unit_cost,
          category: row.category,
          location: row.location,
          // Include the location IDs from the database
          locationId: row.location_id,
          shelfId: row.shelf_id,
          supplier: row.supplier,
          lastRestockDate: row.last_restock_date
        };
      });
    } catch (err) {
      log(`Error retrieving parts: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return [];
    }
  }
  
  async getPartsByLocation(locationId?: number, shelfId?: number): Promise<Part[]> {
    try {
      console.log(`GET /parts - Getting parts with filters: locationId=${locationId}, shelfId=${shelfId}`);
      
      // Since our database just has a text 'location' field, we need to determine 
      // the location and shelf names to filter parts
      let locationName = "";
      let shelfName = "";
      
      if (locationId) {
        const locationResult = await pool.query('SELECT name FROM storage_locations WHERE id = $1', [locationId]);
        if (locationResult.rows.length > 0) {
          locationName = locationResult.rows[0].name;
          console.log(`Looking for location name: ${locationName}`);
        }
      }
      
      if (shelfId) {
        const shelfResult = await pool.query('SELECT name FROM shelves WHERE id = $1', [shelfId]);
        if (shelfResult.rows.length > 0) {
          shelfName = shelfResult.rows[0].name;
          console.log(`Looking for shelf name: ${shelfName}`);
        }
      }
      
      let queryText = `SELECT * FROM parts`;
      const queryParams: any[] = [];
      
      // If we have both location and shelf, we need to filter for parts that have both in their location field
      if (locationName && shelfName) {
        queryText += ` WHERE location LIKE $1`;
        queryParams.push(`%${locationName}%${shelfName}%`);
      }
      // If we only have location name, filter for that
      else if (locationName) {
        queryText += ` WHERE location LIKE $1`;
        queryParams.push(`%${locationName}%`);
      }
      // If we only have shelf name, filter for that
      else if (shelfName) {
        queryText += ` WHERE location LIKE $1`;
        queryParams.push(`%${shelfName}%`);
      }
      
      queryText += ` ORDER BY name ASC`;
      
      console.log(`Executing query: ${queryText} with params: ${queryParams}`);
      const result = await pool.query(queryText, queryParams);
      console.log(`GET /parts - Found ${result.rows.length} parts`);
      
      if (result.rows.length > 0) {
        console.log(`GET /parts - First part: ${JSON.stringify(result.rows[0])}`);
      }
      
      return result.rows.map(row => ({
        id: row.id,
        partId: row.part_id,
        name: row.name,
        description: row.description,
        quantity: row.quantity,
        reorderLevel: row.reorder_level,
        unitCost: row.unit_cost,
        category: row.category,
        location: row.location,
        // Include the location IDs from the database
        locationId: row.location_id,
        shelfId: row.shelf_id,
        supplier: row.supplier,
        lastRestockDate: row.last_restock_date
      }));
    } catch (err) {
      log(`Error fetching parts by location: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return [];
    }
  }

  async getLowStockParts(): Promise<PartWithAvailability[]> {
    try {
      const result = await pool.query(`
        SELECT * FROM parts 
        WHERE reorder_level IS NOT NULL AND quantity <= reorder_level
        ORDER BY name
      `);
      
      return result.rows.map(row => {
        // Calculate availability based on quantity and reorder level
        let availability: 'low' | 'medium' | 'high' = 'high';
        
        if (row.reorder_level !== null) {
          if (row.quantity <= row.reorder_level * 0.5) {
            availability = 'low';
          } else if (row.quantity <= row.reorder_level) {
            availability = 'medium';
          }
        }
        
        return {
          id: row.id,
          partId: row.part_id,
          name: row.name,
          description: row.description,
          quantity: row.quantity,
          reorderLevel: row.reorder_level,
          unitCost: row.unit_cost,
          category: row.category,
          location: row.location,
          // Include the location IDs from the database
          locationId: row.location_id,
          shelfId: row.shelf_id,
          supplier: row.supplier,
          lastRestockDate: row.last_restock_date,
          availability
        };
      });
    } catch (err) {
      log(`Error retrieving low stock parts: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return [];
    }
  }

  // Parts Issuance operations
  async getPartsIssuance(id: number): Promise<PartsIssuance | undefined> {
    try {
      const result = await pool.query(
        'SELECT * FROM parts_issuance WHERE id = $1',
        [id]
      );
      
      if (result.rows.length === 0) {
        return undefined;
      }
      
      const row = result.rows[0];
      return {
        id: row.id,
        partId: row.part_id,
        quantity: row.quantity,
        issuedAt: row.issued_at,
        issuedTo: row.issued_to,
        issuedById: row.issued_by_id, // Changed from issuedBy to issuedById to match database structure
        reason: row.reason,
        projectCode: row.project_code,
        notes: row.notes
      };
    } catch (err) {
      log(`Error retrieving parts issuance: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return undefined;
    }
  }

  async createPartsIssuance(issuance: InsertPartsIssuance): Promise<PartsIssuance> {
    try {
      const client = await pool.connect();
      
      try {
        await client.query('BEGIN');
        
        // First, get the current part to check quantity
        const partResult = await client.query(
          'SELECT * FROM parts WHERE id = $1',
          [issuance.partId]
        );
        
        if (partResult.rows.length === 0) {
          throw new Error(`Part with ID ${issuance.partId} not found`);
        }
        
        const part = partResult.rows[0];
        
        if (part.quantity < issuance.quantity) {
          throw new Error(`Insufficient quantity available for part ${part.name}`);
        }
        
        // Update part quantity
        await client.query(
          'UPDATE parts SET quantity = quantity - $1 WHERE id = $2',
          [issuance.quantity, issuance.partId]
        );
        
        // Create issuance record
        const result = await client.query(
          `INSERT INTO parts_issuance (
             part_id, quantity, issued_at, issued_to, 
             issued_by, reason, project_code, notes
           )
           VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
           RETURNING *`,
          [
            issuance.partId,
            issuance.quantity,
            issuance.issuedAt || new Date(),
            issuance.issuedTo,
            issuance.issuedById, // Changed from issuedBy to issuedById
            issuance.reason,
            issuance.projectCode,
            issuance.notes
          ]
        );
        
        await client.query('COMMIT');
        
        const row = result.rows[0];
        return {
          id: row.id,
          partId: row.part_id,
          quantity: row.quantity,
          issuedAt: row.issued_at,
          issuedTo: row.issued_to,
          issuedById: row.issued_by_id, // Changed to issuedById
          reason: row.reason,
          projectCode: row.project_code,
          notes: row.notes
        };
      } catch (err) {
        await client.query('ROLLBACK');
        log(`Error in transaction - createPartsIssuance: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
        throw err;
      } finally {
        client.release();
      }
    } catch (err) {
      log(`Error creating parts issuance: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      throw new Error(`Failed to create parts issuance: ${err instanceof Error ? err.message : String(err)}`);
    }
  }

  async getPartsIssuanceByPartId(partId: number): Promise<PartsIssuanceWithDetails[]> {
    try {
      const result = await pool.query(`
        SELECT 
          pi.*,
          p.part_id as part_part_id, 
          p.name as part_name,
          p.description as part_description,
          p.category as part_category,
          p.location as part_location,
          p.location_id as part_location_id,
          p.shelf_id as part_shelf_id,
          p.unit_cost as part_unit_cost,
          u.name as issued_by_name,
          u.role as issued_by_role,
          u.department as issued_by_department
        FROM parts_issuance pi
        JOIN parts p ON pi.part_id = p.id
        LEFT JOIN users u ON pi.issued_by_id = u.id
        WHERE pi.part_id = $1
        ORDER BY pi.issued_at DESC
      `, [partId]);
      
      return result.rows.map(row => ({
        id: row.id,
        partId: row.part_id,
        quantity: row.quantity,
        issuedAt: row.issued_at,
        issuedTo: row.issued_to,
        issuedById: row.issued_by_id,
        reason: row.reason,
        projectCode: row.project_code,
        notes: row.notes,
        department: row.department,
        part: {
          id: row.part_id,
          partId: row.part_part_id,
          name: row.part_name,
          description: row.part_description,
          quantity: row.quantity, // We just show the issued quantity here
          reorderLevel: null,
          unitCost: row.part_unit_cost,
          category: row.part_category,
          location: row.part_location,
          supplier: null,
          lastRestockDate: null
        },
        issuedByUser: row.issued_by_id ? {
          id: row.issued_by_id,
          username: '',  // Don't expose username
          password: '',  // Don't expose password
          name: row.issued_by_name,
          role: row.issued_by_role,
          department: row.issued_by_department
        } : undefined
      }));
    } catch (err) {
      log(`Error retrieving parts issuance by part ID: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return [];
    }
  }

  async getRecentPartsIssuance(limit: number): Promise<PartsIssuanceWithDetails[]> {
    try {
      const result = await pool.query(`
        SELECT 
          pi.*,
          p.part_id as part_part_id, 
          p.name as part_name,
          p.description as part_description,
          p.category as part_category,
          p.location as part_location,
          p.location_id as part_location_id,
          p.shelf_id as part_shelf_id,
          p.unit_cost as part_unit_cost
        FROM parts_issuance pi
        JOIN parts p ON pi.part_id = p.id
        ORDER BY pi.issued_at DESC
        LIMIT $1
      `, [limit]);
      
      return result.rows.map(row => ({
        id: row.id,
        partId: row.part_id,
        quantity: row.quantity,
        issuedAt: row.issued_at,
        issuedTo: row.issued_to,
        issuedById: row.issued_by_id,
        reason: row.reason,
        projectCode: row.project_code,
        notes: row.notes,
        department: row.department,
        part: {
          id: row.part_id,
          partId: row.part_part_id,
          name: row.part_name,
          description: row.part_description,
          quantity: row.quantity, // We just show the issued quantity here
          reorderLevel: null,
          unitCost: row.part_unit_cost,
          category: row.part_category,
          location: row.part_location,
          supplier: null,
          lastRestockDate: null
        },
        issuedByUser: row.issued_by_id ? {
          id: row.issued_by_id,
          username: '',  // Don't expose username
          password: '',  // Don't expose password
          name: row.issued_by_name,
          role: row.issued_by_role,
          department: row.issued_by_department
        } : undefined
      }));
    } catch (err) {
      log(`Error retrieving recent parts issuance: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return [];
    }
  }

  async getMonthlyPartsIssuanceTotal(): Promise<number> {
    try {
      // First try to create the reset_flags table if it doesn't exist
      try {
        await pool.query(`
          CREATE TABLE IF NOT EXISTS reset_flags (
            key TEXT PRIMARY KEY,
            value BOOLEAN,
            reset_at TIMESTAMP
          )
        `);
        
        // Check for a manual reset flag in the table
        const resetResult = await pool.query(`
          SELECT value, reset_at 
          FROM reset_flags 
          WHERE key = 'monthly_issuance_reset'
        `);
        
        if (resetResult.rows.length > 0 && resetResult.rows[0].value === true) {
          const resetAt = new Date(resetResult.rows[0].reset_at);
          
          // Only count parts issued AFTER the reset
          const result = await pool.query(`
            SELECT COUNT(*) as total
            FROM parts_issuance
            WHERE issued_at > $1
          `, [resetAt]);
          
          return parseInt(result.rows[0].total, 10);
        }
      } catch (resetErr) {
        // If the reset_flags table doesn't exist, just ignore the error
        // and proceed with normal counting
        console.log("Reset flag check failed (table may not exist):", resetErr);
      }
      
      // If no valid reset flag is found, do the normal monthly count
      // FIXED: Use SUM of quantities rather than COUNT of rows to get accurate total
      const result = await pool.query(`
        SELECT COALESCE(SUM(quantity), 0) as total
        FROM parts_issuance
        WHERE issued_at >= date_trunc('month', CURRENT_DATE)
      `);
      
      console.log("Monthly parts issuance count result:", result.rows[0]);
      return parseInt(result.rows[0].total, 10);
    } catch (err) {
      log(`Error retrieving monthly parts issuance total: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return 0;
    }
  }

  // Parts to Count operations
  async createPartsToCount(partsToCount: InsertPartsToCount): Promise<PartsToCount> {
    try {
      const result = await pool.query(
        `INSERT INTO parts_to_count (part_id, assigned_by_id, status, notes)
         VALUES ($1, $2, $3, $4)
         RETURNING *`,
        [
          partsToCount.partId,
          partsToCount.assignedById || null,
          partsToCount.status || 'pending',
          partsToCount.notes || null
        ]
      );
      
      const row = result.rows[0];
      return {
        id: row.id,
        partId: row.part_id,
        assignedById: row.assigned_by_id,
        status: row.status || 'pending',
        assignedAt: row.assigned_at || new Date(),
        completedAt: row.completed_at,
        notes: row.notes
      };
    } catch (err) {
      log(`Error creating parts to count assignment: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      throw new Error(`Failed to create parts to count assignment: ${err instanceof Error ? err.message : String(err)}`);
    }
  }
  
  async getPartsToCount(): Promise<PartsToCountWithDetails[]> {
    try {
      const result = await pool.query(`
        SELECT ptc.*, 
               p.id as part_id, p.part_id as part_part_id, p.name as part_name, 
               p.description as part_description, p.quantity as part_quantity,
               p.reorder_level as part_reorder_level, p.location as part_location,
               p.category as part_category, p.supplier as part_supplier,
               p.unit_cost as part_unit_cost,
               p.last_restock_date as part_last_restock_date,
               u.id as user_id, u.name as user_name, u.username as user_username,
               u.role as user_role, u.department as user_department
        FROM parts_to_count ptc
        JOIN parts p ON ptc.part_id = p.id
        LEFT JOIN users u ON ptc.assigned_by_id = u.id
        ORDER BY ptc.assigned_at DESC
      `);
      
      return result.rows.map(row => ({
        id: row.id,
        partId: row.part_id,
        assignedById: row.assigned_by_id,
        status: row.status,
        assignedAt: row.assigned_at,
        completedAt: row.completed_at,
        notes: row.notes,
        part: {
          id: row.part_id,
          partId: row.part_part_id,
          name: row.part_name,
          description: row.part_description,
          quantity: row.part_quantity,
          reorderLevel: row.part_reorder_level,
          unitCost: row.part_unit_cost,
          location: row.part_location,
          category: row.part_category,
          supplier: row.part_supplier,
          lastRestockDate: row.part_last_restock_date
        },
        assignedBy: row.user_id ? {
          id: row.user_id,
          username: row.user_username,
          name: row.user_name,
          role: row.user_role,
          department: row.user_department,
          password: '' // Password is not returned for security
        } : undefined
      }));
    } catch (err) {
      log(`Error retrieving parts to count: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return [];
    }
  }
  
  async getPendingPartsToCount(): Promise<PartsToCountWithDetails[]> {
    try {
      const result = await pool.query(`
        SELECT ptc.*, 
               p.id as part_id, p.part_id as part_part_id, p.name as part_name, 
               p.description as part_description, p.quantity as part_quantity,
               p.reorder_level as part_reorder_level, p.location as part_location,
               p.category as part_category, p.supplier as part_supplier,
               p.unit_cost as part_unit_cost,
               p.last_restock_date as part_last_restock_date,
               u.id as user_id, u.name as user_name, u.username as user_username,
               u.role as user_role, u.department as user_department
        FROM parts_to_count ptc
        JOIN parts p ON ptc.part_id = p.id
        LEFT JOIN users u ON ptc.assigned_by_id = u.id
        WHERE ptc.status = 'pending'
        ORDER BY ptc.assigned_at DESC
      `);
      
      return result.rows.map(row => ({
        id: row.id,
        partId: row.part_id,
        assignedById: row.assigned_by_id,
        status: row.status,
        assignedAt: row.assigned_at,
        completedAt: row.completed_at,
        notes: row.notes,
        part: {
          id: row.part_id,
          partId: row.part_part_id,
          name: row.part_name,
          description: row.part_description,
          quantity: row.part_quantity,
          reorderLevel: row.part_reorder_level,
          unitCost: row.part_unit_cost,
          location: row.part_location,
          category: row.part_category,
          supplier: row.part_supplier,
          lastRestockDate: row.part_last_restock_date
        },
        assignedBy: row.user_id ? {
          id: row.user_id,
          username: row.user_username,
          name: row.user_name,
          role: row.user_role,
          department: row.user_department,
          password: '' // Password is not returned for security
        } : undefined
      }));
    } catch (err) {
      log(`Error retrieving pending parts to count: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return [];
    }
  }
  
  async updatePartsToCountStatus(id: number, status: string, completedAt?: Date): Promise<PartsToCount | undefined> {
    try {
      const now = completedAt || (status === 'completed' ? new Date() : null);
      const result = await pool.query(
        `UPDATE parts_to_count 
         SET status = $1, 
             completed_at = $2
         WHERE id = $3
         RETURNING *`,
        [status, now, id]
      );
      
      if (result.rows.length === 0) {
        return undefined;
      }
      
      const row = result.rows[0];
      return {
        id: row.id,
        partId: row.part_id,
        assignedById: row.assigned_by_id,
        status: row.status,
        assignedAt: row.assigned_at,
        completedAt: row.completed_at,
        notes: row.notes
      };
    } catch (err) {
      log(`Error updating parts to count status: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return undefined;
    }
  }
  
  async deletePartsToCount(id: number): Promise<boolean> {
    try {
      const result = await pool.query(
        'DELETE FROM parts_to_count WHERE id = $1',
        [id]
      );
      
      return result.rowCount > 0;
    } catch (err) {
      log(`Error deleting parts to count: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return false;
    }
  }

  // Parts Pickup operations
  async getPartsPickup(id: number): Promise<PartsPickup | undefined> {
    const client = await this.pool.connect();
    try {
      const result = await client.query(
        `SELECT * FROM parts_pickup WHERE id = $1`,
        [id]
      );
      
      if (result.rows.length === 0) {
        return undefined;
      }
      
      return {
        id: result.rows[0].id,
        partName: result.rows[0].part_name,
        partNumber: result.rows[0].part_number,
        quantity: result.rows[0].quantity,
        supplier: result.rows[0].supplier,
        buildingId: result.rows[0].building_id,
        addedById: result.rows[0].added_by_id,
        addedAt: result.rows[0].added_at,
        pickedUpById: result.rows[0].picked_up_by_id,
        pickedUpAt: result.rows[0].picked_up_at,
        status: result.rows[0].status,
        notes: result.rows[0].notes,
        trackingNumber: result.rows[0].tracking_number,
        poNumber: result.rows[0].po_number,
        pickupCode: result.rows[0].pickup_code
      };
    } catch (error) {
      console.error('Error getting parts pickup:', error);
      return undefined;
    } finally {
      client.release();
    }
  }
  
  async getPartsPickups(): Promise<PartsPickupWithDetails[]> {
    const client = await this.pool.connect();
    try {
      const result = await client.query(`
        SELECT 
          pp.*,
          b.name as building_name,
          b.description as building_description,
          added_user.name as added_by_name,
          picked_user.name as picked_up_by_name
        FROM parts_pickup pp
        LEFT JOIN buildings b ON pp.building_id = b.id
        LEFT JOIN users added_user ON pp.added_by_id = added_user.id
        LEFT JOIN users picked_user ON pp.picked_up_by_id = picked_user.id
        ORDER BY pp.added_at DESC
      `);
      
      return result.rows.map(row => {
        const building = row.building_id ? {
          id: row.building_id,
          name: row.building_name,
          description: row.building_description
        } : undefined;
        
        const addedBy = row.added_by_id ? {
          id: row.added_by_id,
          name: row.added_by_name
        } : undefined;
        
        const pickedUpBy = row.picked_up_by_id ? {
          id: row.picked_up_by_id,
          name: row.picked_up_by_name
        } : undefined;
        
        return {
          id: row.id,
          partName: row.part_name,
          partNumber: row.part_number,
          quantity: row.quantity,
          supplier: row.supplier,
          buildingId: row.building_id,
          addedById: row.added_by_id,
          addedAt: row.added_at,
          pickedUpById: row.picked_up_by_id,
          pickedUpAt: row.picked_up_at,
          status: row.status,
          notes: row.notes,
          trackingNumber: row.tracking_number,
          poNumber: row.po_number,
          building,
          addedBy,
          pickedUpBy
        };
      });
    } catch (error) {
      console.error('Error getting parts pickups:', error);
      return [];
    } finally {
      client.release();
    }
  }
  
  async getPendingPartsPickups(): Promise<PartsPickupWithDetails[]> {
    const client = await this.pool.connect();
    try {
      const result = await client.query(`
        SELECT 
          pp.*,
          b.name as building_name,
          b.description as building_description,
          added_user.name as added_by_name,
          picked_user.name as picked_up_by_name
        FROM parts_pickup pp
        LEFT JOIN buildings b ON pp.building_id = b.id
        LEFT JOIN users added_user ON pp.added_by_id = added_user.id
        LEFT JOIN users picked_user ON pp.picked_up_by_id = picked_user.id
        WHERE pp.status = 'pending'
        ORDER BY pp.added_at DESC
      `);
      
      return result.rows.map(row => {
        const building = row.building_id ? {
          id: row.building_id,
          name: row.building_name,
          description: row.building_description
        } : undefined;
        
        const addedBy = row.added_by_id ? {
          id: row.added_by_id,
          name: row.added_by_name
        } : undefined;
        
        const pickedUpBy = row.picked_up_by_id ? {
          id: row.picked_up_by_id,
          name: row.picked_up_by_name
        } : undefined;
        
        return {
          id: row.id,
          partName: row.part_name,
          partNumber: row.part_number,
          quantity: row.quantity,
          supplier: row.supplier,
          buildingId: row.building_id,
          addedById: row.added_by_id,
          addedAt: row.added_at,
          pickedUpById: row.picked_up_by_id,
          pickedUpAt: row.picked_up_at,
          status: row.status,
          notes: row.notes,
          trackingNumber: row.tracking_number,
          poNumber: row.po_number,
          building,
          addedBy,
          pickedUpBy
        };
      });
    } catch (error) {
      console.error('Error getting pending parts pickups:', error);
      return [];
    } finally {
      client.release();
    }
  }
  
  async createPartsPickup(partsPickup: InsertPartsPickup): Promise<PartsPickup> {
    const client = await this.pool.connect();
    try {
      // Generate a random 4-digit pickup code
      const pickupCode = Math.floor(1000 + Math.random() * 9000).toString();
      
      const result = await client.query(`
        INSERT INTO parts_pickup (
          part_name, part_number, quantity, supplier, building_id,
          added_by_id, notes, tracking_number, po_number, status, pickup_code
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
        RETURNING *
      `, [
        partsPickup.partName,
        partsPickup.partNumber || null,
        partsPickup.quantity || 1,
        partsPickup.supplier || null,
        partsPickup.buildingId || null,
        partsPickup.addedById,
        partsPickup.notes || null,
        partsPickup.trackingNumber || null,
        partsPickup.poNumber || null,
        'pending', // Default status for new parts pickups
        pickupCode  // Add the random 4-digit code
      ]);
      
      return {
        id: result.rows[0].id,
        partName: result.rows[0].part_name,
        partNumber: result.rows[0].part_number,
        quantity: result.rows[0].quantity,
        supplier: result.rows[0].supplier,
        buildingId: result.rows[0].building_id,
        addedById: result.rows[0].added_by_id,
        addedAt: result.rows[0].added_at,
        pickedUpById: result.rows[0].picked_up_by_id,
        pickedUpAt: result.rows[0].picked_up_at,
        status: result.rows[0].status,
        notes: result.rows[0].notes,
        trackingNumber: result.rows[0].tracking_number,
        poNumber: result.rows[0].po_number,
        pickupCode: result.rows[0].pickup_code
      };
    } catch (error) {
      console.error('Error creating parts pickup:', error);
      throw error;
    } finally {
      client.release();
    }
  }
  
  async updatePartsPickupStatus(id: number, technicianId: number): Promise<PartsPickup | undefined> {
    const client = await this.pool.connect();
    try {
      const now = new Date();
      const result = await client.query(`
        UPDATE parts_pickup 
        SET status = 'completed', picked_up_by_id = $2, picked_up_at = $3
        WHERE id = $1
        RETURNING *
      `, [id, technicianId, now]);
      
      if (result.rows.length === 0) {
        return undefined;
      }
      
      return {
        id: result.rows[0].id,
        partName: result.rows[0].part_name,
        partNumber: result.rows[0].part_number,
        quantity: result.rows[0].quantity,
        supplier: result.rows[0].supplier,
        buildingId: result.rows[0].building_id,
        addedById: result.rows[0].added_by_id,
        addedAt: result.rows[0].added_at,
        pickedUpById: result.rows[0].picked_up_by_id,
        pickedUpAt: result.rows[0].picked_up_at,
        status: result.rows[0].status,
        notes: result.rows[0].notes,
        trackingNumber: result.rows[0].tracking_number,
        poNumber: result.rows[0].po_number,
        pickupCode: result.rows[0].pickup_code
      };
    } catch (error) {
      console.error('Error updating parts pickup status:', error);
      return undefined;
    } finally {
      client.release();
    }
  }
  
  async deletePartsPickup(id: number): Promise<boolean> {
    const client = await this.pool.connect();
    try {
      const result = await client.query(
        `DELETE FROM parts_pickup WHERE id = $1 RETURNING id`,
        [id]
      );
      
      return result.rowCount === 1;
    } catch (error) {
      console.error('Error deleting parts pickup:', error);
      return false;
    } finally {
      client.release();
    }
  }

  // Settings operations
  async getNotificationSettings(): Promise<NotificationSettings> {
    try {
      const result = await pool.query('SELECT * FROM notification_settings LIMIT 1');
      
      if (result.rows.length === 0) {
        return this.notificationSettings;
      }
      
      const row = result.rows[0];
      return {
        system: {
          companyName: row.company_name || "Ohio Northern University",
          systemEmail: row.system_email || "m-gierhart@onu.edu"
        },
        workOrders: {
          newWorkOrders: row.work_orders_new,
          statusChanges: row.work_orders_status,
          comments: row.work_orders_comments
        },
        inventory: {
          lowStockAlerts: row.inventory_low_stock,
          partIssuance: row.inventory_issuance
        }
      };
    } catch (err) {
      log(`Error retrieving notification settings: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return this.notificationSettings;
    }
  }

  async updateNotificationSettings(settings: NotificationSettings): Promise<NotificationSettings> {
    try {
      const result = await pool.query(`
        UPDATE notification_settings
        SET work_orders_new = $1,
            work_orders_status = $2,
            work_orders_comments = $3,
            inventory_low_stock = $4,
            inventory_issuance = $5,
            company_name = $6,
            system_email = $7,
            updated_at = CURRENT_TIMESTAMP
        RETURNING *
      `, [
        settings.workOrders.newWorkOrders,
        settings.workOrders.statusChanges,
        settings.workOrders.comments,
        settings.inventory.lowStockAlerts,
        settings.inventory.partIssuance,
        settings.system?.companyName || "Ohio Northern University",
        settings.system?.systemEmail || "m-gierhart@onu.edu"
      ]);
      
      if (result.rows.length === 0) {
        // If no rows were updated, insert new settings
        const insertResult = await pool.query(`
          INSERT INTO notification_settings (
            work_orders_new, work_orders_status, work_orders_comments,
            inventory_low_stock, inventory_issuance,
            company_name, system_email
          )
          VALUES ($1, $2, $3, $4, $5, $6, $7)
          RETURNING *
        `, [
          settings.workOrders.newWorkOrders,
          settings.workOrders.statusChanges,
          settings.workOrders.comments,
          settings.inventory.lowStockAlerts,
          settings.inventory.partIssuance,
          settings.system?.companyName || "Ohio Northern University",
          settings.system?.systemEmail || "m-gierhart@onu.edu"
        ]);
        
        const row = insertResult.rows[0];
        this.notificationSettings = {
          workOrders: {
            newWorkOrders: row.work_orders_new,
            statusChanges: row.work_orders_status,
            comments: row.work_orders_comments
          },
          inventory: {
            lowStockAlerts: row.inventory_low_stock,
            partIssuance: row.inventory_issuance
          }
        };
      } else {
        const row = result.rows[0];
        this.notificationSettings = {
          workOrders: {
            newWorkOrders: row.work_orders_new,
            statusChanges: row.work_orders_status,
            comments: row.work_orders_comments
          },
          inventory: {
            lowStockAlerts: row.inventory_low_stock,
            partIssuance: row.inventory_issuance
          }
        };
      }
      
      return this.notificationSettings;
    } catch (err) {
      log(`Error updating notification settings: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return this.notificationSettings;
    }
  }

  // Storage Location operations
  async getStorageLocation(id: number): Promise<StorageLocation | undefined> {
    try {
      const result = await pool.query(
        'SELECT * FROM storage_locations WHERE id = $1',
        [id]
      );
      return result.rows.length > 0 ? result.rows[0] : undefined;
    } catch (error) {
      console.error('Error getting storage location:', error);
      return undefined;
    }
  }

  async getStorageLocations(): Promise<StorageLocation[]> {
    try {
      const result = await pool.query('SELECT * FROM storage_locations ORDER BY name');
      return result.rows;
    } catch (error) {
      console.error('Error getting storage locations:', error);
      return [];
    }
  }

  async createStorageLocation(location: InsertStorageLocation): Promise<StorageLocation> {
    try {
      const result = await pool.query(
        'INSERT INTO storage_locations (name, description, active) VALUES ($1, $2, $3) RETURNING *',
        [location.name, location.description || null, location.active !== undefined ? location.active : true]
      );
      return result.rows[0];
    } catch (error) {
      console.error('Error creating storage location:', error);
      throw error;
    }
  }

  async updateStorageLocation(id: number, location: Partial<InsertStorageLocation>): Promise<StorageLocation | undefined> {
    try {
      const current = await this.getStorageLocation(id);
      if (!current) return undefined;

      const updates: string[] = [];
      const values: any[] = [];
      let paramIndex = 1;

      if (location.name !== undefined) {
        updates.push(`name = $${paramIndex++}`);
        values.push(location.name);
      }
      if (location.description !== undefined) {
        updates.push(`description = $${paramIndex++}`);
        values.push(location.description);
      }
      if (location.active !== undefined) {
        updates.push(`active = $${paramIndex++}`);
        values.push(location.active);
      }

      if (updates.length === 0) return current;

      values.push(id);
      const query = `UPDATE storage_locations SET ${updates.join(', ')} WHERE id = $${paramIndex} RETURNING *`;
      const result = await pool.query(query, values);
      return result.rows[0];
    } catch (error) {
      console.error('Error updating storage location:', error);
      return undefined;
    }
  }

  async deleteStorageLocation(id: number): Promise<boolean> {
    try {
      // First check if there are any shelves referencing this location
      const shelvesResult = await pool.query(
        'SELECT COUNT(*) FROM shelves WHERE location_id = $1',
        [id]
      );
      if (parseInt(shelvesResult.rows[0].count) > 0) {
        throw new Error('Cannot delete location with associated shelves');
      }

      // Also check if there are any parts referencing this location
      const partsResult = await pool.query(
        'SELECT COUNT(*) FROM parts WHERE location_id = $1',
        [id]
      );
      if (parseInt(partsResult.rows[0].count) > 0) {
        throw new Error('Cannot delete location with associated parts');
      }

      const result = await pool.query('DELETE FROM storage_locations WHERE id = $1', [id]);
      return result.rowCount > 0;
    } catch (error) {
      console.error('Error deleting storage location:', error);
      throw error;
    }
  }

  // Shelf operations
  async getShelf(id: number): Promise<Shelf | undefined> {
    try {
      const result = await pool.query(
        'SELECT * FROM shelves WHERE id = $1',
        [id]
      );
      return result.rows.length > 0 ? result.rows[0] : undefined;
    } catch (error) {
      console.error('Error getting shelf:', error);
      return undefined;
    }
  }

  async getShelves(): Promise<Shelf[]> {
    try {
      console.log("pgStorage.getShelves() called - fetching shelves from database");
      // Remove any LIMIT that might be restricting the results
      const result = await pool.query(`
        SELECT 
          id,
          location_id AS "locationId",
          name,
          description,
          active,
          created_at AS "createdAt"
        FROM shelves 
        ORDER BY location_id, name
      `);
      
      console.log(`pgStorage.getShelves() found ${result.rows.length} shelves`);
      if (result.rows.length === 0) {
        // Double-check with count query to ensure we're not missing data
        const countResult = await pool.query('SELECT COUNT(*) FROM shelves');
        const count = parseInt(countResult.rows[0].count);
        console.log(`Double-check count query shows ${count} shelves in database`);
      } else {
        // Log some samples to debug
        console.log("Sample shelves:", result.rows.slice(0, 5));
      }
      
      return result.rows;
    } catch (error) {
      console.error('Error getting shelves:', error);
      return [];
    }
  }

  async getShelvesByLocation(locationId: number): Promise<Shelf[]> {
    try {
      const result = await pool.query(`
        SELECT 
          id,
          location_id AS "locationId",
          name,
          description,
          active,
          created_at AS "createdAt"
        FROM shelves 
        WHERE location_id = $1 
        ORDER BY name
      `, [locationId]);
      return result.rows;
    } catch (error) {
      console.error('Error getting shelves by location:', error);
      return [];
    }
  }

  async createShelf(shelf: InsertShelf): Promise<Shelf> {
    try {
      // First check if the location exists
      const locationExists = await this.getStorageLocation(shelf.locationId);
      if (!locationExists) {
        throw new Error(`Location with ID ${shelf.locationId} does not exist`);
      }

      const result = await pool.query(
        'INSERT INTO shelves (location_id, name, description, active) VALUES ($1, $2, $3, $4) RETURNING *',
        [shelf.locationId, shelf.name, shelf.description || null, shelf.active !== undefined ? shelf.active : true]
      );
      return result.rows[0];
    } catch (error) {
      console.error('Error creating shelf:', error);
      throw error;
    }
  }

  async updateShelf(id: number, shelf: Partial<InsertShelf>): Promise<Shelf | undefined> {
    try {
      const current = await this.getShelf(id);
      if (!current) return undefined;

      // If location ID is being updated, verify it exists
      if (shelf.locationId !== undefined && shelf.locationId !== current.locationId) {
        const locationExists = await this.getStorageLocation(shelf.locationId);
        if (!locationExists) {
          throw new Error(`Location with ID ${shelf.locationId} does not exist`);
        }
      }

      const updates: string[] = [];
      const values: any[] = [];
      let paramIndex = 1;

      if (shelf.locationId !== undefined) {
        updates.push(`location_id = $${paramIndex++}`);
        values.push(shelf.locationId);
      }
      if (shelf.name !== undefined) {
        updates.push(`name = $${paramIndex++}`);
        values.push(shelf.name);
      }
      if (shelf.description !== undefined) {
        updates.push(`description = $${paramIndex++}`);
        values.push(shelf.description);
      }
      if (shelf.active !== undefined) {
        updates.push(`active = $${paramIndex++}`);
        values.push(shelf.active);
      }

      if (updates.length === 0) return current;

      values.push(id);
      const query = `UPDATE shelves SET ${updates.join(', ')} WHERE id = $${paramIndex} RETURNING *`;
      const result = await pool.query(query, values);
      return result.rows[0];
    } catch (error) {
      console.error('Error updating shelf:', error);
      throw error;
    }
  }

  async deleteShelf(id: number): Promise<boolean> {
    try {
      // Check if there are any parts referencing this shelf
      const partsResult = await pool.query(
        'SELECT COUNT(*) FROM parts WHERE shelf_id = $1',
        [id]
      );
      if (parseInt(partsResult.rows[0].count) > 0) {
        throw new Error('Cannot delete shelf with associated parts');
      }

      const result = await pool.query('DELETE FROM shelves WHERE id = $1', [id]);
      return result.rowCount > 0;
    } catch (error) {
      console.error('Error deleting shelf:', error);
      throw error;
    }
  }
}

// Export a singleton instance of the PostgreSQL storage
export const pgStorage = new PgStorage();