import pg from 'pg';
const { Pool } = pg;
import { 
  User, InsertUser, 
  Building, InsertBuilding, 
  Part, InsertPart, 
  PartsIssuance, InsertPartsIssuance, 
  PartWithAvailability,
  PartsIssuanceWithDetails
} from '@shared/schema';
import { IStorage, NotificationSettings } from './storage';
import { log } from './vite';

// Initialize PostgreSQL connection pool from environment variables
const pool = new Pool({
  connectionString: process.env.DATABASE_URL
});

// Test database connection
pool.query('SELECT NOW()', (err, res) => {
  if (err) {
    log(`Database connection error: ${err.message}`, 'postgres');
  } else {
    log(`Database connected at ${res.rows[0].now}`, 'postgres');
  }
});

/**
 * PostgreSQL Storage Implementation
 */
export class PgStorage implements IStorage {
  private initialized: boolean = false;
  private notificationSettings: NotificationSettings = {
    workOrders: {
      newWorkOrders: true,
      statusChanges: true,
      comments: true,
    },
    inventory: {
      lowStockAlerts: true,
      partIssuance: true,
    }
  };

  constructor() {
    this.initDb();
  }

  /**
   * Initialize the database tables if they don't exist
   */
  public async initDb() {
    if (this.initialized) return;

    try {
      // Start a transaction
      const client = await pool.connect();
      
      try {
        await client.query('BEGIN');

        // Create users table
        await client.query(`
          CREATE TABLE IF NOT EXISTS users (
            id SERIAL PRIMARY KEY,
            username VARCHAR(50) UNIQUE NOT NULL,
            password VARCHAR(100) NOT NULL,
            name VARCHAR(100) NOT NULL,
            email VARCHAR(100),
            role VARCHAR(20) NOT NULL,
            department VARCHAR(100),
            phone VARCHAR(20),
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          )
        `);

        // Create buildings table
        await client.query(`
          CREATE TABLE IF NOT EXISTS buildings (
            id SERIAL PRIMARY KEY,
            name VARCHAR(100) NOT NULL,
            location VARCHAR(100),
            description TEXT,
            contact_person VARCHAR(100),
            contact_email VARCHAR(100),
            contact_phone VARCHAR(20),
            active BOOLEAN DEFAULT TRUE,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          )
        `);

        // Create parts table
        await client.query(`
          CREATE TABLE IF NOT EXISTS parts (
            id SERIAL PRIMARY KEY,
            part_id VARCHAR(50) UNIQUE NOT NULL,
            name VARCHAR(100) NOT NULL,
            description TEXT,
            quantity INTEGER NOT NULL DEFAULT 0,
            reorder_level INTEGER,
            unit_cost DECIMAL(10, 2),
            category VARCHAR(50),
            location VARCHAR(100),
            supplier VARCHAR(100),
            last_restock_date TIMESTAMP,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          )
        `);

        // Create parts_issuance table
        await client.query(`
          CREATE TABLE IF NOT EXISTS parts_issuance (
            id SERIAL PRIMARY KEY,
            part_id INTEGER NOT NULL REFERENCES parts(id) ON DELETE CASCADE,
            quantity INTEGER NOT NULL,
            issued_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            issued_to VARCHAR(100),
            issued_by INTEGER REFERENCES users(id),
            reason VARCHAR(50) NOT NULL,
            project_code VARCHAR(50),
            notes TEXT
          )
        `);

        // Create notification_settings table
        await client.query(`
          CREATE TABLE IF NOT EXISTS notification_settings (
            id SERIAL PRIMARY KEY,
            work_orders_new BOOLEAN DEFAULT TRUE,
            work_orders_status BOOLEAN DEFAULT TRUE,
            work_orders_comments BOOLEAN DEFAULT TRUE,
            inventory_low_stock BOOLEAN DEFAULT TRUE,
            inventory_issuance BOOLEAN DEFAULT TRUE,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          )
        `);

        // Insert default notification settings if none exist
        await client.query(`
          INSERT INTO notification_settings 
            (work_orders_new, work_orders_status, work_orders_comments, 
             inventory_low_stock, inventory_issuance)
          SELECT TRUE, TRUE, TRUE, TRUE, TRUE
          WHERE NOT EXISTS (SELECT 1 FROM notification_settings)
        `);

        // Insert admin user if no users exist
        await client.query(`
          INSERT INTO users (username, password, name, email, role)
          SELECT 'admin', 'admin', 'Administrator', 'm-gierhart@onu.edu', 'admin'
          WHERE NOT EXISTS (SELECT 1 FROM users)
        `);

        await client.query('COMMIT');
        this.initialized = true;
        log('Database tables initialized successfully', 'postgres');
      } catch (err) {
        await client.query('ROLLBACK');
        log(`Database initialization error: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
        throw err;
      } finally {
        client.release();
      }
    } catch (err) {
      log(`Database connection error: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
    }
  }

  // User operations
  async getUser(id: number): Promise<User | undefined> {
    try {
      const result = await pool.query(
        'SELECT * FROM users WHERE id = $1',
        [id]
      );
      
      if (result.rows.length === 0) {
        return undefined;
      }
      
      const row = result.rows[0];
      return {
        id: row.id,
        username: row.username,
        password: row.password,
        name: row.name,
        email: row.email,
        role: row.role,
        department: row.department,
        phone: row.phone
      };
    } catch (err) {
      log(`Error retrieving user: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return undefined;
    }
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    try {
      const result = await pool.query(
        'SELECT * FROM users WHERE username = $1',
        [username]
      );
      
      if (result.rows.length === 0) {
        return undefined;
      }
      
      const row = result.rows[0];
      return {
        id: row.id,
        username: row.username,
        password: row.password,
        name: row.name,
        email: row.email,
        role: row.role,
        department: row.department,
        phone: row.phone
      };
    } catch (err) {
      log(`Error retrieving user by username: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return undefined;
    }
  }

  async createUser(user: InsertUser): Promise<User> {
    try {
      const result = await pool.query(
        `INSERT INTO users (username, password, name, email, role, department, phone)
         VALUES ($1, $2, $3, $4, $5, $6, $7)
         RETURNING *`,
        [
          user.username,
          user.password,
          user.name,
          user.email,
          user.role,
          user.department,
          user.phone
        ]
      );
      
      const row = result.rows[0];
      return {
        id: row.id,
        username: row.username,
        password: row.password,
        name: row.name,
        email: row.email,
        role: row.role,
        department: row.department,
        phone: row.phone
      };
    } catch (err) {
      log(`Error creating user: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      throw new Error(`Failed to create user: ${err instanceof Error ? err.message : String(err)}`);
    }
  }

  async updateUser(id: number, user: Partial<InsertUser>): Promise<User | undefined> {
    try {
      // Build dynamic query based on provided fields
      const updates: string[] = [];
      const values: any[] = [];
      let paramIndex = 1;

      if (user.username !== undefined) {
        updates.push(`username = $${paramIndex++}`);
        values.push(user.username);
      }
      if (user.password !== undefined) {
        updates.push(`password = $${paramIndex++}`);
        values.push(user.password);
      }
      if (user.name !== undefined) {
        updates.push(`name = $${paramIndex++}`);
        values.push(user.name);
      }
      if (user.email !== undefined) {
        updates.push(`email = $${paramIndex++}`);
        values.push(user.email);
      }
      if (user.role !== undefined) {
        updates.push(`role = $${paramIndex++}`);
        values.push(user.role);
      }
      if (user.department !== undefined) {
        updates.push(`department = $${paramIndex++}`);
        values.push(user.department);
      }
      if (user.phone !== undefined) {
        updates.push(`phone = $${paramIndex++}`);
        values.push(user.phone);
      }

      if (updates.length === 0) {
        return await this.getUser(id);
      }

      values.push(id);
      const query = `
        UPDATE users 
        SET ${updates.join(', ')} 
        WHERE id = $${paramIndex} 
        RETURNING *
      `;

      const result = await pool.query(query, values);
      
      if (result.rows.length === 0) {
        return undefined;
      }
      
      const row = result.rows[0];
      return {
        id: row.id,
        username: row.username,
        password: row.password,
        name: row.name,
        email: row.email,
        role: row.role,
        department: row.department,
        phone: row.phone
      };
    } catch (err) {
      log(`Error updating user: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return undefined;
    }
  }

  async getUsers(): Promise<User[]> {
    try {
      const result = await pool.query('SELECT * FROM users ORDER BY name');
      
      return result.rows.map(row => ({
        id: row.id,
        username: row.username,
        password: row.password,
        name: row.name,
        email: row.email,
        role: row.role,
        department: row.department,
        phone: row.phone
      }));
    } catch (err) {
      log(`Error retrieving users: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return [];
    }
  }

  async getTechnicians(): Promise<User[]> {
    try {
      const result = await pool.query(
        "SELECT * FROM users WHERE role = 'technician' ORDER BY name"
      );
      
      return result.rows.map(row => ({
        id: row.id,
        username: row.username,
        password: row.password,
        name: row.name,
        email: row.email,
        role: row.role,
        department: row.department,
        phone: row.phone
      }));
    } catch (err) {
      log(`Error retrieving technicians: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return [];
    }
  }

  async deleteUser(id: number): Promise<boolean> {
    try {
      const result = await pool.query(
        'DELETE FROM users WHERE id = $1',
        [id]
      );
      
      return result.rowCount > 0;
    } catch (err) {
      log(`Error deleting user: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return false;
    }
  }

  // Building operations
  async getBuilding(id: number): Promise<Building | undefined> {
    try {
      const result = await pool.query(
        'SELECT * FROM buildings WHERE id = $1',
        [id]
      );
      
      if (result.rows.length === 0) {
        return undefined;
      }
      
      const row = result.rows[0];
      return {
        id: row.id,
        name: row.name,
        location: row.location,
        description: row.description,
        contactPerson: row.contact_person,
        contactEmail: row.contact_email,
        contactPhone: row.contact_phone,
        active: row.active !== false,
        createdAt: row.created_at
      };
    } catch (err) {
      log(`Error retrieving building: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return undefined;
    }
  }

  async getBuildings(): Promise<Building[]> {
    try {
      const result = await pool.query('SELECT * FROM buildings ORDER BY name');
      
      return result.rows.map(row => ({
        id: row.id,
        name: row.name,
        location: row.location,
        description: row.description,
        contactPerson: row.contact_person,
        contactEmail: row.contact_email,
        contactPhone: row.contact_phone,
        active: row.active !== false, // Default to true if not explicitly set to false
        createdAt: row.created_at
      }));
    } catch (err) {
      log(`Error retrieving buildings: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return [];
    }
  }

  async createBuilding(building: InsertBuilding): Promise<Building> {
    try {
      const result = await pool.query(
        `INSERT INTO buildings (
           name, location, description, contact_person, 
           contact_email, contact_phone, active
         )
         VALUES ($1, $2, $3, $4, $5, $6, $7)
         RETURNING *`,
        [
          building.name,
          building.location,
          building.description,
          building.contactPerson,
          building.contactEmail,
          building.contactPhone,
          building.active !== undefined ? building.active : true
        ]
      );
      
      const row = result.rows[0];
      return {
        id: row.id,
        name: row.name,
        location: row.location,
        description: row.description,
        contactPerson: row.contact_person,
        contactEmail: row.contact_email,
        contactPhone: row.contact_phone
      };
    } catch (err) {
      log(`Error creating building: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      throw new Error(`Failed to create building: ${err instanceof Error ? err.message : String(err)}`);
    }
  }

  async updateBuilding(id: number, building: Partial<InsertBuilding>): Promise<Building | undefined> {
    try {
      // Build dynamic query based on provided fields
      const updates: string[] = [];
      const values: any[] = [];
      let paramIndex = 1;

      if (building.name !== undefined) {
        updates.push(`name = $${paramIndex++}`);
        values.push(building.name);
      }
      if (building.location !== undefined) {
        updates.push(`location = $${paramIndex++}`);
        values.push(building.location);
      }
      if (building.description !== undefined) {
        updates.push(`description = $${paramIndex++}`);
        values.push(building.description);
      }
      if (building.contactPerson !== undefined) {
        updates.push(`contact_person = $${paramIndex++}`);
        values.push(building.contactPerson);
      }
      if (building.contactEmail !== undefined) {
        updates.push(`contact_email = $${paramIndex++}`);
        values.push(building.contactEmail);
      }
      if (building.contactPhone !== undefined) {
        updates.push(`contact_phone = $${paramIndex++}`);
        values.push(building.contactPhone);
      }

      if (updates.length === 0) {
        return await this.getBuilding(id);
      }

      values.push(id);
      const query = `
        UPDATE buildings 
        SET ${updates.join(', ')} 
        WHERE id = $${paramIndex} 
        RETURNING *
      `;

      const result = await pool.query(query, values);
      
      if (result.rows.length === 0) {
        return undefined;
      }
      
      const row = result.rows[0];
      return {
        id: row.id,
        name: row.name,
        location: row.location,
        description: row.description,
        contactPerson: row.contact_person,
        contactEmail: row.contact_email,
        contactPhone: row.contact_phone
      };
    } catch (err) {
      log(`Error updating building: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return undefined;
    }
  }

  async deleteBuilding(id: number): Promise<boolean> {
    try {
      const result = await pool.query(
        'DELETE FROM buildings WHERE id = $1',
        [id]
      );
      
      return result.rowCount > 0;
    } catch (err) {
      log(`Error deleting building: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return false;
    }
  }

  // Part operations
  async getPart(id: number): Promise<Part | undefined> {
    try {
      const result = await pool.query(
        'SELECT * FROM parts WHERE id = $1',
        [id]
      );
      
      if (result.rows.length === 0) {
        return undefined;
      }
      
      const row = result.rows[0];
      return {
        id: row.id,
        partId: row.part_id,
        name: row.name,
        description: row.description,
        quantity: row.quantity,
        reorderLevel: row.reorder_level,
        unitCost: row.unit_cost,
        category: row.category,
        location: row.location,
        supplier: row.supplier,
        lastRestockDate: row.last_restock_date
      };
    } catch (err) {
      log(`Error retrieving part: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return undefined;
    }
  }

  async getPartByPartId(partId: string): Promise<Part | undefined> {
    try {
      const result = await pool.query(
        'SELECT * FROM parts WHERE part_id = $1',
        [partId]
      );
      
      if (result.rows.length === 0) {
        return undefined;
      }
      
      const row = result.rows[0];
      return {
        id: row.id,
        partId: row.part_id,
        name: row.name,
        description: row.description,
        quantity: row.quantity,
        reorderLevel: row.reorder_level,
        unitCost: row.unit_cost,
        category: row.category,
        location: row.location,
        supplier: row.supplier,
        lastRestockDate: row.last_restock_date
      };
    } catch (err) {
      log(`Error retrieving part by partId: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return undefined;
    }
  }

  async createPart(part: InsertPart): Promise<Part> {
    try {
      const result = await pool.query(
        `INSERT INTO parts (
           part_id, name, description, quantity, reorder_level,
           unit_cost, category, location, supplier, last_restock_date
         )
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
         RETURNING *`,
        [
          part.partId,
          part.name,
          part.description,
          part.quantity,
          part.reorderLevel,
          part.unitCost,
          part.category,
          part.location,
          part.supplier,
          part.lastRestockDate
        ]
      );
      
      const row = result.rows[0];
      return {
        id: row.id,
        partId: row.part_id,
        name: row.name,
        description: row.description,
        quantity: row.quantity,
        reorderLevel: row.reorder_level,
        unitCost: row.unit_cost,
        category: row.category,
        location: row.location,
        supplier: row.supplier,
        lastRestockDate: row.last_restock_date
      };
    } catch (err) {
      log(`Error creating part: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      throw new Error(`Failed to create part: ${err instanceof Error ? err.message : String(err)}`);
    }
  }

  async updatePart(id: number, part: Partial<InsertPart>): Promise<Part | undefined> {
    try {
      // Build dynamic query based on provided fields
      const updates: string[] = [];
      const values: any[] = [];
      let paramIndex = 1;

      if (part.partId !== undefined) {
        updates.push(`part_id = $${paramIndex++}`);
        values.push(part.partId);
      }
      if (part.name !== undefined) {
        updates.push(`name = $${paramIndex++}`);
        values.push(part.name);
      }
      if (part.description !== undefined) {
        updates.push(`description = $${paramIndex++}`);
        values.push(part.description);
      }
      if (part.quantity !== undefined) {
        updates.push(`quantity = $${paramIndex++}`);
        values.push(part.quantity);
      }
      if (part.reorderLevel !== undefined) {
        updates.push(`reorder_level = $${paramIndex++}`);
        values.push(part.reorderLevel);
      }
      if (part.unitCost !== undefined) {
        updates.push(`unit_cost = $${paramIndex++}`);
        values.push(part.unitCost);
      }
      if (part.category !== undefined) {
        updates.push(`category = $${paramIndex++}`);
        values.push(part.category);
      }
      if (part.location !== undefined) {
        updates.push(`location = $${paramIndex++}`);
        values.push(part.location);
      }
      if (part.supplier !== undefined) {
        updates.push(`supplier = $${paramIndex++}`);
        values.push(part.supplier);
      }
      if (part.lastRestockDate !== undefined) {
        updates.push(`last_restock_date = $${paramIndex++}`);
        values.push(part.lastRestockDate);
      }

      if (updates.length === 0) {
        return await this.getPart(id);
      }

      values.push(id);
      const query = `
        UPDATE parts 
        SET ${updates.join(', ')} 
        WHERE id = $${paramIndex} 
        RETURNING *
      `;

      const result = await pool.query(query, values);
      
      if (result.rows.length === 0) {
        return undefined;
      }
      
      const row = result.rows[0];
      return {
        id: row.id,
        partId: row.part_id,
        name: row.name,
        description: row.description,
        quantity: row.quantity,
        reorderLevel: row.reorder_level,
        unitCost: row.unit_cost,
        category: row.category,
        location: row.location,
        supplier: row.supplier,
        lastRestockDate: row.last_restock_date
      };
    } catch (err) {
      log(`Error updating part: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return undefined;
    }
  }

  async getParts(): Promise<Part[]> {
    try {
      const result = await pool.query('SELECT * FROM parts ORDER BY name');
      
      return result.rows.map(row => ({
        id: row.id,
        partId: row.part_id,
        name: row.name,
        description: row.description,
        quantity: row.quantity,
        reorderLevel: row.reorder_level,
        unitCost: row.unit_cost,
        category: row.category,
        location: row.location,
        supplier: row.supplier,
        lastRestockDate: row.last_restock_date
      }));
    } catch (err) {
      log(`Error retrieving parts: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return [];
    }
  }

  async getLowStockParts(): Promise<PartWithAvailability[]> {
    try {
      const result = await pool.query(`
        SELECT * FROM parts 
        WHERE reorder_level IS NOT NULL AND quantity <= reorder_level
        ORDER BY name
      `);
      
      return result.rows.map(row => {
        // Calculate availability based on quantity and reorder level
        let availability: 'low' | 'medium' | 'high' = 'high';
        
        if (row.reorder_level !== null) {
          if (row.quantity <= row.reorder_level * 0.5) {
            availability = 'low';
          } else if (row.quantity <= row.reorder_level) {
            availability = 'medium';
          }
        }
        
        return {
          id: row.id,
          partId: row.part_id,
          name: row.name,
          description: row.description,
          quantity: row.quantity,
          reorderLevel: row.reorder_level,
          unitCost: row.unit_cost,
          category: row.category,
          location: row.location,
          supplier: row.supplier,
          lastRestockDate: row.last_restock_date,
          availability
        };
      });
    } catch (err) {
      log(`Error retrieving low stock parts: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return [];
    }
  }

  // Parts Issuance operations
  async getPartsIssuance(id: number): Promise<PartsIssuance | undefined> {
    try {
      const result = await pool.query(
        'SELECT * FROM parts_issuance WHERE id = $1',
        [id]
      );
      
      if (result.rows.length === 0) {
        return undefined;
      }
      
      const row = result.rows[0];
      return {
        id: row.id,
        partId: row.part_id,
        quantity: row.quantity,
        issuedAt: row.issued_at,
        issuedTo: row.issued_to,
        issuedBy: row.issued_by,
        reason: row.reason,
        projectCode: row.project_code,
        notes: row.notes
      };
    } catch (err) {
      log(`Error retrieving parts issuance: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return undefined;
    }
  }

  async createPartsIssuance(issuance: InsertPartsIssuance): Promise<PartsIssuance> {
    try {
      const client = await pool.connect();
      
      try {
        await client.query('BEGIN');
        
        // First, get the current part to check quantity
        const partResult = await client.query(
          'SELECT * FROM parts WHERE id = $1',
          [issuance.partId]
        );
        
        if (partResult.rows.length === 0) {
          throw new Error(`Part with ID ${issuance.partId} not found`);
        }
        
        const part = partResult.rows[0];
        
        if (part.quantity < issuance.quantity) {
          throw new Error(`Insufficient quantity available for part ${part.name}`);
        }
        
        // Update part quantity
        await client.query(
          'UPDATE parts SET quantity = quantity - $1 WHERE id = $2',
          [issuance.quantity, issuance.partId]
        );
        
        // Create issuance record
        const result = await client.query(
          `INSERT INTO parts_issuance (
             part_id, quantity, issued_at, issued_to, 
             issued_by, reason, project_code, notes
           )
           VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
           RETURNING *`,
          [
            issuance.partId,
            issuance.quantity,
            issuance.issuedAt || new Date(),
            issuance.issuedTo,
            issuance.issuedBy,
            issuance.reason,
            issuance.projectCode,
            issuance.notes
          ]
        );
        
        await client.query('COMMIT');
        
        const row = result.rows[0];
        return {
          id: row.id,
          partId: row.part_id,
          quantity: row.quantity,
          issuedAt: row.issued_at,
          issuedTo: row.issued_to,
          issuedBy: row.issued_by,
          reason: row.reason,
          projectCode: row.project_code,
          notes: row.notes
        };
      } catch (err) {
        await client.query('ROLLBACK');
        log(`Error in transaction - createPartsIssuance: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
        throw err;
      } finally {
        client.release();
      }
    } catch (err) {
      log(`Error creating parts issuance: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      throw new Error(`Failed to create parts issuance: ${err instanceof Error ? err.message : String(err)}`);
    }
  }

  async getPartsIssuanceByPartId(partId: number): Promise<PartsIssuanceWithDetails[]> {
    try {
      const result = await pool.query(`
        SELECT pi.*, p.part_id as part_part_id, p.name as part_name, 
               u.name as issued_by_name
        FROM parts_issuance pi
        JOIN parts p ON pi.part_id = p.id
        LEFT JOIN users u ON pi.issued_by = u.id
        WHERE pi.part_id = $1
        ORDER BY pi.issued_at DESC
      `, [partId]);
      
      return result.rows.map(row => ({
        id: row.id,
        partId: row.part_id,
        quantity: row.quantity,
        issuedAt: row.issued_at,
        issuedTo: row.issued_to,
        issuedBy: row.issued_by,
        reason: row.reason,
        projectCode: row.project_code,
        notes: row.notes,
        part: {
          id: row.part_id,
          partId: row.part_part_id,
          name: row.part_name,
          description: null,
          quantity: 0,
          reorderLevel: null,
          unitCost: null,
          category: null,
          location: null,
          supplier: null,
          lastRestockDate: null
        },
        issuedByUser: row.issued_by ? {
          id: row.issued_by,
          username: '',
          password: '',
          name: row.issued_by_name,
          email: null,
          role: 'user',
          department: null,
          phone: null
        } : undefined
      }));
    } catch (err) {
      log(`Error retrieving parts issuance by part ID: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return [];
    }
  }

  async getRecentPartsIssuance(limit: number): Promise<PartsIssuanceWithDetails[]> {
    try {
      const result = await pool.query(`
        SELECT pi.*, p.part_id as part_part_id, p.name as part_name, 
               u.name as issued_by_name
        FROM parts_issuance pi
        JOIN parts p ON pi.part_id = p.id
        LEFT JOIN users u ON pi.issued_by = u.id
        ORDER BY pi.issued_at DESC
        LIMIT $1
      `, [limit]);
      
      return result.rows.map(row => ({
        id: row.id,
        partId: row.part_id,
        quantity: row.quantity,
        issuedAt: row.issued_at,
        issuedTo: row.issued_to,
        issuedBy: row.issued_by,
        reason: row.reason,
        projectCode: row.project_code,
        notes: row.notes,
        part: {
          id: row.part_id,
          partId: row.part_part_id,
          name: row.part_name,
          description: null,
          quantity: 0,
          reorderLevel: null,
          unitCost: null,
          category: null,
          location: null,
          supplier: null,
          lastRestockDate: null
        },
        issuedByUser: row.issued_by ? {
          id: row.issued_by,
          username: '',
          password: '',
          name: row.issued_by_name,
          email: null,
          role: 'user',
          department: null,
          phone: null
        } : undefined
      }));
    } catch (err) {
      log(`Error retrieving recent parts issuance: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return [];
    }
  }

  async getMonthlyPartsIssuanceTotal(): Promise<number> {
    try {
      const result = await pool.query(`
        SELECT COUNT(*) as total
        FROM parts_issuance
        WHERE issued_at >= date_trunc('month', CURRENT_DATE)
      `);
      
      return parseInt(result.rows[0].total, 10);
    } catch (err) {
      log(`Error retrieving monthly parts issuance total: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return 0;
    }
  }

  // Settings operations
  async getNotificationSettings(): Promise<NotificationSettings> {
    try {
      const result = await pool.query('SELECT * FROM notification_settings LIMIT 1');
      
      if (result.rows.length === 0) {
        return this.notificationSettings;
      }
      
      const row = result.rows[0];
      return {
        workOrders: {
          newWorkOrders: row.work_orders_new,
          statusChanges: row.work_orders_status,
          comments: row.work_orders_comments
        },
        inventory: {
          lowStockAlerts: row.inventory_low_stock,
          partIssuance: row.inventory_issuance
        }
      };
    } catch (err) {
      log(`Error retrieving notification settings: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return this.notificationSettings;
    }
  }

  async updateNotificationSettings(settings: NotificationSettings): Promise<NotificationSettings> {
    try {
      const result = await pool.query(`
        UPDATE notification_settings
        SET work_orders_new = $1,
            work_orders_status = $2,
            work_orders_comments = $3,
            inventory_low_stock = $4,
            inventory_issuance = $5,
            updated_at = CURRENT_TIMESTAMP
        RETURNING *
      `, [
        settings.workOrders.newWorkOrders,
        settings.workOrders.statusChanges,
        settings.workOrders.comments,
        settings.inventory.lowStockAlerts,
        settings.inventory.partIssuance
      ]);
      
      if (result.rows.length === 0) {
        // If no rows were updated, insert new settings
        const insertResult = await pool.query(`
          INSERT INTO notification_settings (
            work_orders_new, work_orders_status, work_orders_comments,
            inventory_low_stock, inventory_issuance
          )
          VALUES ($1, $2, $3, $4, $5)
          RETURNING *
        `, [
          settings.workOrders.newWorkOrders,
          settings.workOrders.statusChanges,
          settings.workOrders.comments,
          settings.inventory.lowStockAlerts,
          settings.inventory.partIssuance
        ]);
        
        const row = insertResult.rows[0];
        this.notificationSettings = {
          workOrders: {
            newWorkOrders: row.work_orders_new,
            statusChanges: row.work_orders_status,
            comments: row.work_orders_comments
          },
          inventory: {
            lowStockAlerts: row.inventory_low_stock,
            partIssuance: row.inventory_issuance
          }
        };
      } else {
        const row = result.rows[0];
        this.notificationSettings = {
          workOrders: {
            newWorkOrders: row.work_orders_new,
            statusChanges: row.work_orders_status,
            comments: row.work_orders_comments
          },
          inventory: {
            lowStockAlerts: row.inventory_low_stock,
            partIssuance: row.inventory_issuance
          }
        };
      }
      
      return this.notificationSettings;
    } catch (err) {
      log(`Error updating notification settings: ${err instanceof Error ? err.message : String(err)}`, 'postgres');
      return this.notificationSettings;
    }
  }
}

// Export a singleton instance of the PostgreSQL storage
export const pgStorage = new PgStorage();